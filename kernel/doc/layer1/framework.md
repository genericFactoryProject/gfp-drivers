本框架应支持“组合和嵌套对象”的能力，这种能力是非常适合线性对象的，例如时间，内存，计数，状态机等，计数可以引申到对象锁等结构。例如，层级锁中同层锁之间属于组合关系，而不同层锁之间属于嵌套关系；状态机中HSM也是这个道理。值得注意的是，不同层之间可以存在顺序关系，例如高层锁获取后，才可以获取低层锁；进入父状态后，才可以进入子状态。

本框架仍要关注“对象关联”的能力，这种能力用于处理对象的关系。这里包括变换（映射），介质（消息/缓存），触发（事件），状态。

## 嵌套组合模型

嵌套，即可以将某个资源以任意的输入请求一层层分解下去，亦可以一层层封装上去；组合，即可以将某些资源以任意的输入请求进行组合和分解。

键值对是描述嵌套组合模型的符合方案。

键可以作为一种有限资源，并且可以静态配置或是动态增减。自然，键也可以是无限的。

在嵌套组合模型中，我比较关心键的层级性，用于符合嵌套特性。同时，我也关心键的集合性，用于符合组合特性。这些特性就是接口或是操作。也就是说，经过嵌套和组合的操作后，旧的键（集合）会转换为新的键集合。

但是，嵌套组合模式的使用场景一般是先基于无键的，也就是说，键的获取和释放是由对象管控且私有，与调用者无关；当然也存在直接使用键的情形。
在嵌套组合接口下，生成的新键可以用于满足“无键”场景。
再者，在存在键之后，可以利用键来引用真正的资源或是说值。

嵌套和组合操作我建议在一个dispatch中解决，这样做成一个模型引擎。

该模型在调度时间和内存地址空间等资源的抽象上表现良好。
定义如下符号: ->作为嵌套符号，++ 作为组合符号。

### 静态内核对象

针对时间和内存可以做如下嵌套和组合模型：
1. 将系统的调度时间抽象为：CPU集群 -> SMP/AMP CPU -> 1时间元 -> 2时间元 -> 3时间元 -> 4时间元 -> 5时间元等
2. 将某一事务的调度时间抽象为：事务 = 某几个1时间元 ++ 某几个2时间元 ++ 某几个CPU时间元 ++ ...

内存也是如此，
1. 嵌套过程：NUMA节点 -> UMA节点 -> 区域 -> 空闲链表 -> 页 -> 对象
2. 组合过程：事务 = 某几个内存对象 ++ 某些页 ++ 某几个区域 ++ 某几个节点 ++ ...

如下是内存和时间的模型示例：
|对照/统一术语|时间|空间|..|
|----|----|----|----|
|集|CPU集群|NUMA节点|..|
|节点|CPU/vCPU|UMA节点/vUMA|..|
|组|1st|区域|..|
|单元|2st|空闲链表|..|
|项|3st|页/vma|..|
|片|4st|对象|..|

时间和内存二者之间的区别在于：
|资源类型|时间|空间|备注|
|----|----|----|----|
|模型向量类型|优先级向量+尺寸向量|<延迟>映射向量+尺寸向量|转换到另一套数据结构 - 统一序列号|
|资源申请策略|相对公平(轮询+FIFO),不公平(优先级单调抢占):在到达时刻前不可享有|绝对公平(FIFO):内存地址立刻享有或是延迟分配|延时参数|
|资源有限性|无限=>有限+周期|有限=>物理内存+热插拔内存+置换内存|流+窗口|
|资源持有策略|阶梯性(任务创建和销毁或部分时间片手动销毁)|长期性(除非置换/释放, 长期持有)|根据不同约束，可以从持有到非持有，生命周期lcc|
|资源操作|分配+释放+使用计数|分配+释放+使用计数|...|

区别意味着二者的操作是不一致的。

笛卡尔积：
|模型向量类型|绘制曲线|扩展含义|
|----|----|----|
|序列号向量+尺寸向量转置|CPU利用曲线|CPU利用率, 响应度, 实时性, 负载均衡度等|
|寻址号向量+尺寸向量转置|内存利用曲线|内存利用率, 内存碎片率等|

### 运行时对象

执行实体：进程组->进程->子进程->线程
每一个执行实体可拥有无限的虚拟资源。
每一个执行实体需要变换到有限的物理资源。
这些资源种类可以包含静态内核对象，或是物理设备等。

## 关联模型

关联，即表示对象之间的关系。这种关系的存在，往往是当前对象不可用或是不是最终目的，故需要转换到另一种对象。
目前，这种关联在同类型对象之间应用的较多。例如，虚拟内存和物理内存，虚拟时间和物理时间，线程之间IPC和事件等。
而对于线程本身，它可能需要聚合一些结构，例如cap,mm,tm,msg_handler等，这种与关联无关。

### 静态内核对象
### 运行时对象

键值对是描述这种关系的强力手段。不过对于不同的关系，键值对的含义不尽相同。以这三个为例子，变换（映射），介质（消息/缓存），触发（事件），状态:

1. 对于变换（映射）来说，键可以是索引或是地址，值可以是值或是地址
2. 对于介质来说，键可以是消息标签，或是缓存索引，值可以是句柄或是值
3. 对于触发来说，键可以是事件类型，值可以是句柄
4. 对于状态来说，键可以是状态，值可以是句柄

不过，单纯的键值对并不能支持全量的关系类型。这个很好理解，对于虚拟地址和物理地址的映射关系，表面上是va->pa，直接映射上。
实际，为了通用性考虑，会考虑延迟分配的机制。
即在使用va的过程中，如果没有存在映射关系，会触发缺页异常，在异常中将映射补齐，再继续执行该va。这个案例就表明键和值的映射上，往往实际情况不是直接的，而是间接，或是由触发源调用的。

总结下来，存在三种执行关系的一元模型：
1. 调用者（主动触发源）使用通知链机制来通知被调用者来支持关系。调用链的实现可以是远程调用或是其他方式
2. 调用者（主动触发源）直接映射来支持关系。例如系统调用
3. 被调用者（被动触发源）来支持关系。例如缺页异常

所谓一元模型，就是说这个关系的执行，由单个调用者就可以支持；而多元模型，则是需要两个及以上的调用者共同协调才能执行。例如，设备驱动模型中bus有两方调用者，一是device，另一个是driver。

角色的定位总是不确定的，某个场景中的调用者有可能是另一个场景中的被调用者，反之亦然。

这种执行流可以是顺序执行，例如通知链，后一个执行依赖于前一个执行的状态。但是，从更通用的角度讲，依照状态机来执行更好。并且，状态机可以退化成通知链，即链式状态。

调用者不限制于某类对象，例如thread对象；也就是说，任意的内核对象都可以或是都可能存在某种关系。所以，一旦梳理出所有可能的关系，就可以梳理出内核的全貌。由关系驱动对象，即由功能驱动对象实现。
目前很多内核都是先设定某些对象实现，例如一些通用的内核对象，这样其实会造成真正功能的遗漏，进而导致内核对象反复修改耦合。

在关联模型中，我不太关注键的层级性。也就是说，默认键是从0开始的连续整数。但是，不代表层级性的键没有市场；例如，HSM模型正是层级键的代表。

关系也不是孤立的；也就是说，关系之间也可能存在着依赖性。例如，状态关系依赖于事件关系，介质关系可能依赖于事件或状态关系。这里我使用父子关系来指定。
甚至说，如果我们使用状态机代替通知链，那状态机的实现完全可以用状态关系来支持。
自然，对于事件或是状态关系来说，我们只能使用通知链。

## AI feasibility

1. Agent，输入用户需求，用于输出事务接口
2. 张量资源管理
3. 机器学习调优
4. AIOS

LLM可以分析用户A语言，从知识库中获取相应的答案，并反馈给用户B。用户A可以是Agent CLI输入的用户需求（自然语言），而用户B可以是资源。
LLM->用户A可以是解析自然语言的过程，而LLM->用户B则是推理输出机器识别语言的过程（这里以事务表示）。
LLM的角色是黑盒。
知识库是训练和记忆的结果。

因此，根据当前分析的情况，需要以下基础设施：
1. Agent应用：CLI或人机交互的接口
2. LLM推理框架：解析自然语言，从知识库获取经验或将经验存储知识库
3. 知识库：经验的持久记忆
4. 事务原语：这里非常依赖OS背景经验，精炼成事务原语库（或标准），由事务驱动资源分配和释放等操作
5. 资源模型：该模型作为资源的抽象，可以根据资源属性，将资源数量，资源边界，资源效率等物理概念转换为数学概念
6. 资源驱动：底层OS管理最基本的物理硬件

模式：
LLM（训练） ----> NC model ----> LLM'（参数校准）

### Note1
事务接口，同传统OS的系统调用接口类似，区别在于该接口不是用来管理资源，而是告知OS去做什么。
例如，数据采集Agent，用户需求为"采集传感器数据，通过CAN总线，输出到文件中"，输出事务接口如下:
1. 任务<优先级, 响应时间，运行时间，截至时间>，例如，数据采集任务
2. 外设<标识(寄存器), 配置(设备特定), 数据地址, 源, 目的>，例如CAN，磁盘等
事务接口可以标准化，类似POSIX标准。
事务接口标准是归纳用户需求，转换为较为通用的机器理解的事务集合的结果。

### Note2
建立统一模型来描述和管理资源。
例如，调度时间，内存地址空间，中断触发概率分布，网络带宽，磁盘分区/带宽，大量外设，通信（IPC/event）阻塞分布区域以及通信缓存带宽，同步阻塞分布区域以及事务性内存分布区域等。
事务接口参数转换为上述"统一模型"的输入，"统一模型"会按照输入需求给出当前系统的资源分配输出。

### Note3
输入不同维度的张量数据（以上描述的），根据业务/用户约束，输出理论最优/近似最优的系统级决策。
例如，在输入各类资源向量，且保证实时约束的前提下，输出任务调度策略，内存分配/释放/置换策略，中断分布策略，网络流量管控策略，磁盘IO管控策略，外设分配策略，通信分布策略/带宽管控策略，同步分布策略等。

### Note4
机器学习算法驱动的设备资源管理器，做它的原因有，内核代码指数级增长的担忧，减少内核漏洞的人力成本的剧增（即使在seL4开发中，形式化验证脚本的成本远超内核设计），复杂的用例需求对内核的畸形改动，内核的多维度启发式参数以“小作坊”的方式进行优化等；而以上所有的担忧，通过机器学习的经验增长来解决。

## Issue & Idea

## TODO

1. RCU引入
2. HSM引入
3. NC Dispatch
4. Xarray XA_CHUNK_SHIFT/XA_MAX_MARKS 不用宏，而是参数配置